import numpy as np

class GeometryKernel:
    def __init__(self, tolerance=1e-6):
        self.tolerance = tolerance

    def is_collinear(self, p1, p2, p3):
        """Checks if three points are collinear."""
        # Calculate the area of the triangle formed by the points.
        # If the area is close to zero, the points are collinear.
        area = 0.5 * (p1[0] * (p2[1] - p3[1]) + p2[0] * (p3[1] - p1[1]) + p3[0] * (p1[1] - p2[1]))
        return abs(area) < self.tolerance

    def point_on_segment(self, p, p1, p2): 
        """Checks if a point p lies on the line segment defined by p1 and p2."""
        # First check collinearity
        if not self.is_collinear(p, p1, p2):
            return False

        # Check if point is within the bounding box of the segment
        if (p[0] >= min(p1[0], p2[0]) and p[0] <= max(p1[0], p2[0]) and
            p[1] >= min(p1[1], p2[1]) and p[1] <= max(p1[1], p2[1])):
            return True
        else:
            return False

    def intersect(self, seg1_p1, seg1_p2, seg2_p1, seg2_p2):
        """Checks if two line segments intersect.  Handles degenerate cases.
           Returns True if they intersect, False otherwise.
        """
        #Orientation function
        def orientation(p,q,r):
            val = (float(q[1]-p[1]) * (r[0]-q[0])) - (float(q[0]-p[0]) * (r[1]-q[1]))
            if (val > self.tolerance): return 1  #Collinear and clock-wise
            if (val < -self.tolerance): return 2 #Collinear and counterclock-wise
            return 0 #collinear

        #General Case
        o1 = orientation(seg1_p1, seg1_p2, seg2_p1)
        o2 = orientation(seg1_p1, seg1_p2, seg2_p2)
        o3 = orientation(seg2_p1, seg2_p2, seg1_p1)
        o4 = orientation(seg2_p1, seg2_p2, seg1_p2)

        if (o1 != o2 and o3 != o4): return True

        #Special Cases - Segments are collinear
        # seg1_p1, seg1_p2, seg2_p1 are collinear and seg2_p1 lies on segment seg1
        if (o1 == 0 and self.point_on_segment(seg2_p1, seg1_p1, seg1_p2)): return True

        # seg1_p1, seg1_p2, seg2_p2 are collinear and seg2_p2 lies on segment seg1
        if (o2 == 0 and self.point_on_segment(seg2_p2, seg1_p1, seg1_p2)): return True

        # seg2_p1, seg2_p2, seg1_p1 are collinear and seg1_p1 lies on segment seg2
        if (o3 == 0 and self.point_on_segment(seg1_p1, seg2_p1, seg2_p2)): return True

        # seg2_p1, seg2_p2, seg1_p2 are collinear and seg1_p2 lies on segment seg2
        if (o4 == 0 and self.point_on_segment(seg1_p2, seg2_p1, seg2_p2)): return True

        return False

    def distance_point_to_segment(self, point, segment_start, segment_end):
        """Calculates the distance from a point to a line segment.
           Handles cases where the segment is a point.
        """
        segment_length = np.sqrt((segment_end[0] - segment_start[0])**2 + (segment_end[1] - segment_start[1])**2)
        if segment_length < self.tolerance:
             # Treat the segment as a point, and return the distance to that point.
            return np.sqrt((point[0] - segment_start[0])**2 + (point[1] - segment_start[1])**2)

        # Project the point onto the line.
        dx = segment_end[0] - segment_start[0]
        dy = segment_end[1] - segment_start[1]

        # Compute the parameter t, which represents the position of the projected point along the line.
        t = ((point[0] - segment_start[0]) * dx + (point[1] - segment_start[1]) * dy) / (dx*dx + dy*dy)

        # If the projected point lies within the segment, return the distance to the line.
        if 0 < t < 1:
            projected_x = segment_start[0] + t * dx
            projected_y = segment_start[1] + t * dy
            return np.sqrt((point[0] - projected_x)**2 + (point[1] - projected_y)**2)
        else:
            # Otherwise, return the distance to the closest endpoint.
            dist_to_start = np.sqrt((point[0] - segment_start[0])**2 + (point[1] - segment_start[1])**2)
            dist_to_end = np.sqrt((point[0] - segment_end[0])**2 + (point[1] - segment_end[1])**2)
            return min(dist_to_start, dist_to_end)
