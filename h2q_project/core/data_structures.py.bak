class DataStructure:
    def __init__(self, data):
        self.data = data

    def process_data(self):
        # Placeholder for data processing.  Subclasses should implement this.
        pass


class OptimizedList(list):
    """A list optimized for memory usage by using slots.
    This prevents the creation of a __dict__ for each element, reducing memory overhead.
    """
    __slots__ = ['_items']

    def __init__(self, iterable=None):
        self._items = []
        if iterable is not None:
            self.extend(iterable)

    def append(self, item):
        self._items.append(item)

    def extend(self, iterable):
        for item in iterable:
            self._items.append(item)

    def __len__(self):
        return len(self._items)

    def __getitem__(self, index):
        return self._items[index]

    def __setitem__(self, index, value):
        self._items[index] = value

    def __delitem__(self, index):
        del self._items[index]

    def __iter__(self):
        return iter(self._items)

    def __contains__(self, item):
        return item in self._items

# Example usage (can be removed after verification)
if __name__ == '__main__':
    # Using the optimized list
    my_list = OptimizedList(range(1000))
    print(f"Length of my_list: {len(my_list)}")
    print(f"First element: {my_list[0]}")

    # Demonstration of memory savings (This is just a conceptual example)
    import sys

    regular_list = list(range(1000))
    optimized_list = OptimizedList(range(1000))

    regular_list_size = sys.getsizeof(regular_list)
    optimized_list_size = sys.getsizeof(optimized_list)

    print(f"Size of regular list: {regular_list_size} bytes")
    print(f"Size of optimized list: {optimized_list_size} bytes")