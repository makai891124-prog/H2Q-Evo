import numpy as np

class GeometryKernel:
    def __init__(self):
        pass

    def calculate_distance(self, point1, point2):
        """Calculates the Euclidean distance between two points.

        Args:
            point1 (np.ndarray): The coordinates of the first point.
            point2 (np.ndarray): The coordinates of the second point.

        Returns:
            float: The Euclidean distance between the two points.
        """
        point1 = np.array(point1)
        point2 = np.array(point2)
        return np.linalg.norm(point1 - point2)

    def is_point_on_line(self, point, line_point1, line_point2, tolerance=1e-6):
        """Checks if a point lies on a line defined by two points.

        Args:
            point (np.ndarray): The coordinates of the point to check.
            line_point1 (np.ndarray): The coordinates of the first point on the line.
            line_point2 (np.ndarray): The coordinates of the second point on the line.
            tolerance (float): Tolerance for numerical comparisons.

        Returns:
            bool: True if the point lies on the line, False otherwise.
        """
        point = np.array(point)
        line_point1 = np.array(line_point1)
        line_point2 = np.array(line_point2)

        # Calculate cross product of vectors (line_point1 -> point) and (line_point1 -> line_point2)
        cross_product = np.cross(point - line_point1, line_point2 - line_point1)

        # If the cross product is close to zero, the point is on the line
        return np.abs(cross_product) < tolerance

    def reflect(self, point, normal):
        """Reflect a point around a normal vector.

        Args:
            point (np.ndarray): Point to reflect.
            normal (np.ndarray): Normal vector to reflect around.

        Returns:
            np.ndarray: Reflected point.
        """
        point = np.array(point)
        normal = np.array(normal)

        # Normalize the normal vector
        normal = normal / np.linalg.norm(normal)

        # Calculate the reflection
        reflected_point = point - 2 * np.dot(point, normal) * normal

        return reflected_point

class SelfReflection:
    def __init__(self, geometry_kernel):
        self.kernel = geometry_kernel

    def validate_distance(self, point1, point2, distance):
        """Validates the calculated distance between two points.

        Args:
            point1 (np.ndarray): The coordinates of the first point.
            point2 (np.ndarray): The coordinates of the second point.
            distance (float): The calculated distance between the points.

        Returns:
            bool: True if the calculated distance is correct, False otherwise.
        """
        calculated_distance = self.kernel.calculate_distance(point1, point2)
        return np.isclose(calculated_distance, distance)

    def validate_point_on_line(self, point, line_point1, line_point2):
        """Validates if a point is on a line.

        Args:
            point (np.ndarray): The coordinates of the point.
            line_point1 (np.ndarray): The coordinates of the first point on the line.
            line_point2 (np.ndarray): The coordinates of the second point on the line.

        Returns:
            bool: True if the point is on the line, False otherwise.
        """
        return self.kernel.is_point_on_line(point, line_point1, line_point2)

    def validate_reflection(self, point, normal, reflected_point):
        """Validates the reflection of a point around a normal vector.

        Args:
            point (np.ndarray): The original point.
            normal (np.ndarray): The normal vector.
            reflected_point (np.ndarray): The reflected point.

        Returns:
            bool: True if the reflection is correct, False otherwise.
        """
        calculated_reflected_point = self.kernel.reflect(point, normal)
        return np.allclose(calculated_reflected_point, reflected_point)

# Example usage:
if __name__ == '__main__':
    kernel = GeometryKernel()
    self_reflection = SelfReflection(kernel)

    # Distance validation
    point1 = [1, 2]
    point2 = [4, 6]
    distance = 5.0
    is_distance_valid = self_reflection.validate_distance(point1, point2, distance)
    print(f"Is distance valid: {is_distance_valid}")

    # Point on line validation
    point = [2, 3]
    line_point1 = [1, 2]
    line_point2 = [3, 4]
    is_point_on_line = self_reflection.validate_point_on_line(point, line_point1, line_point2)
    print(f"Is point on line: {is_point_on_line}")

    # Reflection validation
    point = [1, 1]
    normal = [0, 1]
    reflected_point = [1, -1]
    is_reflection_valid = self_reflection.validate_reflection(point, normal, reflected_point)
    print(f"Is reflection valid: {is_reflection_valid}")