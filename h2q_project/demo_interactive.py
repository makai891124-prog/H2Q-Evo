import torch
import numpy as np
import time
import sys
from typing import Tuple, List

# --- EXPERIMENTAL CODE: H2Q COGNITIVE INTERFACE ---
# This module implements the Geodesic Flow inference loop and Spectral Shift tracking.

class H2QInteractiveDemo:
    def __init__(self, model_path: str = "checkpoints/h2q_core.pt"):
        self.device = torch.device("mps" if torch.backends.mps.is_available() else "cpu")
        self.manifold_dim = 256
        print(f"[M24-CW] Initializing H2Q Engine on {self.device}...")
        
        # In a production scenario, we load the DiscreteDecisionEngine and H2QSyntheticEngine.
        # For this demo, we initialize the manifold structure to demonstrate the Geodesic Flow.
        try:
            # Placeholder for actual model loading logic
            # self.engine = torch.load(model_path).to(self.device)
            self.is_mock = True
            print("[!] Warning: Using initialized manifold (No checkpoint found). Status: EXPERIMENTAL.")
        except Exception as e:
            self.is_mock = True

    def text_to_atoms(self, text: str) -> torch.Tensor:
        """Converts discrete text into SU(2) atoms (byte-level mapping)."""
        bytes_data = text.encode('utf-8')
        atoms = torch.tensor([b for b in bytes_data], dtype=torch.float32).to(self.device)
        # Normalize to [0, 1] for manifold projection
        return atoms / 255.0

    def compute_spectral_shift(self, s_matrix: torch.Tensor) -> float:
        """
        Implements the Krein-like trace formula:
        η = (1/π) arg{det(S)}
        """
        # Ensure we are dealing with a square matrix for determinant
        # In H2Q, S is the scattering matrix of the geodesic flow
        det_s = torch.linalg.det(s_matrix)
        phase = torch.angle(det_s)
        eta = phase / np.pi
        return eta.item()

    def geodesic_flow_step(self, state: torch.Tensor) -> Tuple[torch.Tensor, float]:
        """
        Simulates infinitesimal rotations in the su(2) Lie Algebra.
        """
        # Create a pseudo-unitary transformation matrix S
        # In reality, this is generated by the H2QSyntheticEngine
        noise = torch.randn(self.manifold_dim, self.manifold_dim, device=self.device) * 0.01
        s_matrix = torch.eye(self.manifold_dim, device=self.device) + noise
        
        # Orthogonalize to maintain SU(2) symmetry (simplified)
        q, r = torch.linalg.qr(s_matrix)
        s_matrix = q
        
        new_state = torch.matmul(s_matrix, state.unsqueeze(-1)).squeeze(-1)
        eta = self.compute_spectral_shift(s_matrix)
        
        return new_state, eta

    def run(self):
        print("\n" + "="*50)
        print("H2Q COGNITIVE WEAVER - INTERACTIVE DEMO")
        print("Architecture: SU(2) Quaternionic Manifold")
        print("Metric: Geodesic Flow / Spectral Shift (η)")
        print("="*50 + "\n")

        while True:
            try:
                user_input = input("\033[94mUser >> \033[0m")
                if user_input.lower() in ['exit', 'quit']:
                    break

                # 1. Atomization
                atoms = self.text_to_atoms(user_input)
                
                # 2. Projection to 256-dim Manifold
                # We pad or truncate to match manifold_dim
                manifold_state = torch.zeros(self.manifold_dim, device=self.device)
                limit = min(len(atoms), self.manifold_dim)
                manifold_state[:limit] = atoms[:limit]

                print(f"\033[90m[Thought Trace] Projecting {len(atoms)} atoms to SU(2) manifold...\033[0m")
                
                # 3. Inference (Geodesic Flow)
                # We simulate 3 recursive symmetry breaking steps
                total_eta = 0.0
                for i in range(3):
                    manifold_state, eta = self.geodesic_flow_step(manifold_state)
                    total_eta += eta
                    print(f"\033[90m[Thought Trace] Step {i+1}: Spectral Shift η = {eta:.6f}\033[0m")

                # 4. Decoding (Simplified for Demo)
                # In H2Q, the DiscreteDecisionEngine maps the final state back to tokens
                response_val = torch.mean(manifold_state).item()
                
                # Logic: Map the mean spectral shift to a 'confidence' or 'state' response
                if total_eta > 0:
                    response = "Symmetry preserved. Geodesic path stable."
                else:
                    response = "Symmetry broken. Fractal expansion initiated."

                print(f"\033[92mH2Q >> \033[0m {response} (Cumulative η: {total_eta:.4f})")
                
            except KeyboardInterrupt:
                break
            except Exception as e:
                print(f"\033[91m[Error] {e}\033[0m")

if __name__ == "__main__":
    demo = H2QInteractiveDemo()
    demo.run()